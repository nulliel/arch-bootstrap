#!/usr/bin/env bash
## Copyright (c) 2017 helmuthdu <helmuthdu@gmail.com>
## Copyright (c) 2017 Stephen Ribich <stephen.ribich@gmail.com>
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

declare PARTITION_DEVICE
declare PARTITION_MOUNT

## PARTITION_LIST is a structure for creating partitions.
## The structure is as follows:
##
##   ID,Sie,Filesystem,Mountpoint,Name,Encrypt,Swap,Modify
##
## ID         (Device ID)
## Size       (Partition Size)       []
## Filesystem (Partition Filesystem) [ext2,ext3,ext4,btrfs.fat32.vfat]
## Mountpoint (Partition Mountpoint) [string]
## Name       (Partition Name)       [string]
## Encrypt    (Partition Encryption) []
## Swap       (Partition Swap)       [partition,file]
## Modify     (Partition Modifyable) []
##
## Note: This structure is an array
##
declare PARTITION_LIST

PARTITION_DEVICE_TRIM=0

PARTITION_LUKS=0
PARTITION_LUKS_DISK=""

################################################################################
##
################################################################################

get_device_size()
{
    printf "%i" "$(blockdev --getsize64 "$1")"
}

get_device_size_pretty()
{
    pretty_print_size "$(get_device_size "$1")"
}

get_device_size_remaining()
{
    local remaining
    local part_arr
    local data_obj

    remaining="$(get_device_size "${PARTITION_DEVICE}")"

    # Reduce boot partition
    IFS="," read -ra part_arr <<< "${PARTITION_BOOT}"
    remaining="$(( remaining - part_arr[1] ))"

    # Reduce swap partition
    IFS="," read -ra part_arr <<< "${PARTITION_SWAP}"
    remaining="$(( remaining - part_arr[1] ))"

    # Reduce data partitions
    for data_obj in "${PARTITION_DATA[@]}"; do
        IFS="," read -ra part_arr <<< "${data_obj}"
        remaining="$(( remaining - part_arr[1] ))"
    done

    printf "%i" "${remaining}"
}

is_space()
{
    [[ "$(( $(get_device_size_remaining) - $1 ))" -gt 0 ]] && return 0
    return 1
}

pretty_print_size()
{
    local size_list=("Bytes" "KiB" "MiB" "GiB" "TiB")
    local size="$1"
    local type=0

    while :; do
        local rounded

        rounded="$(printf "%1.0f" "${size}")"

        if [[ "${rounded}" -lt 1024 ]]; then
            break
        fi

        size="$(printf "%s / 1024\n" "${size}" | bc -l)"
        type="$(( type + 1 ))"
    done

    printf "%0.1f %s" "${size}" "${size_list[${type}]}"
}

create_partition()
{
    local id="0"
    local size="0"
    local filesystem=""
    local mountpoint=""
    local name=""
    local encrypt="no"
    local swap=""
    local modify="yes"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--id") id="$2" ;;
            "--size") size="$2" ;;
            "--filesystem") filesystem="$2" ;;
            "--mountpoint") mountpoint="$2" ;;
            "--name") name="$2" ;;
            "--encrypt") encrypt="$2" ;;
            "--swap") swap="$2" ;;
            "--modify") modify="$2" ;;
        esac

        shift
        shift
    done

    PARTITION_LIST+=(
        "$(printf "%s,%s,%s,%s,%s,%s,%s,%s" \
                  "${id}"                   \
                  "${size}"                 \
                  "${filesystem}"           \
                  "${mountpoint}"           \
                  "${name}"                 \
                  "${encrypt}"              \
                  "${swap}"                 \
                  "${modify}")"
    )
}

################################################################################
## Size Conversions
################################################################################

print_size_conversion_chart()
{
    print_info "Size Conversion Chart"

    printf "1K ->          1024 Bytes (1 KiB)\n"
    printf "1M ->       1048576 Bytes (1 MiB)\n"
    printf "1G ->    1073741824 Bytes (1 GiB)\n"
    printf "1T -> 1099511627776 Bytes (1 TiB)\n"
    printf "\n"
}

print_size_conversion()
{
    local power="${1: -1}"
    local value="${1::-1}"

    local converted

    if [[ ! "${value}" =~ ^[0-9]+$ || "${value}" -eq 0 ]]; then
        return 1
    fi

    case "${power}" in
        "K")
            converted="$(( 1024 * value ))"
            ;;
        "M")
            converted="$(( 1048576 * value ))"
            ;;
        "G")
            converted="$(( 1073741824 * value ))"
            ;;
        "T")
            converted="$(( 1099511627776 * value ))"
            ;;
        *)
            if [[ ! "${power}" =~ ^[0-9]$ ]]; then
                return 1
            fi

            converted="$1"
            ;;
    esac

    printf "%i" "${converted}"
    return 0
}

################################################################################
## Device Selection
################################################################################

show_devices()
{
    local device_arr
    local device_str

    device_arr=(
        $(grep "sd\|nvme\|blkext" "/proc/devices" | awk '{ print $1 }')
    )

    device_str="$(printf "%s" "${device_arr[*]}" | tr ' ' ',')"

    print.info "Device List"

    lsblk -npI "${device_str}"        \
        | awk '{ print $1,$4,$6,$7 }' \
        | column -t

    printf "\n"
}

select_device()
{
    local device_list

    mapfile -t device_list < <(lsblk -dp | grep -P "sd|hd|vd|nvme|mmcblk")

    print.title "PARTITION - Select Device"

    show_devices

    selection.create "Select a Device to Partition" \
              "${device_list[@]}"

    PARTITION_DEVICE="${SELECTION_VALUE}"
}

################################################################################
## Device Unmounting
################################################################################

umount_partitions()
{
    local partitions

    mapfile -t partitions < <(
        lsblk -nro MOUNTPOINT | sed '/^$/d' | sed '/SWAP/d' | sort -r
    )

    # Disable swap in case it is mapped to a mounted partition
    swapoff -a

    for i in "${partitions[@]}"; do
        umount "${i}"
    done
}

################################################################################
## Boot Partition
################################################################################

create_boot_partition()
{
    create_partition --size 536870912            \
                     --filesystem fat32          \
                     --mountpoint /boot          \
                     --name "EFI Boot Partition" \
                     --writable no
}

################################################################################
## Swap Partition
################################################################################

print_recommended_swap_size()
{
    local memory
    local size

    memory=$(free -g --si     \
                 | grep "Mem" \
                 | awk '{ print $2 }')

    if [[ "${memory}" -le 2 ]]; then
        size=$(( memory * 2 ))
    elif [[ "${memory}" -le 8 ]]; then
        size=$(( memory ))
    elif [[ "${memory}" -le 64 ]]; then
        size=$(( memory / 2 ))
    else
        size=4
    fi

    print_info "$(printf "Recommended Swap Size: %s GiB" "${size}")"
}

select_swap_size()
{
    local ans
    local size

    while :; do
        print_title "PARTITION - Create Swap"

        print_size_conversion_chart
        print_recommended_swap_size

        read -erp "Swap Size: " ans

        size="$(print_size_conversion "${ans}")" || {
            invalid_option
            continue
        }

        if ! is_space "${size}"; then
            pause_function "Not enough space on device. Try again"
            continue
        fi

        swap_size="${size}"
        break
    done
}

create_swap_partition()
{
    local swap_size
    local swap_type

    print_title "PARTITION - Create Swap"

    selection "Select a Swap Implementation" \
              "Swap Partition"               \
              "Swap File"                    \
              "None"

    case "${SELECTION_VALUE}" in
        "Swap Partition")
            swap_type="partition"
            ;;
        "Swap File")
            swap_type="file"
            ;;
        "None")
            swap_type="none"
            ;;
    esac

    if [[ "${swap_type}" != "none" ]]; then
        select_swap_size
    else
        swap_size=0
    fi

    PARTITION_SWAP="2,${swap_size},${swap_type},vfat"
}

################################################################################
## Root Partition
################################################################################

create_root_partition()
{
    PARTITION_DATA+=("0,$(get_device_size_remaining),ext4,no,/,Root Partition")
    align_data_partitions
}

################################################################################
## Partition Scheme
################################################################################

## Assign data partitions a new device id. This is run every time the
## partition list is modified to preserve a linear device id chain
##
align_data_partitions()
{
    local -i length="${#PARTITION_DATA[@]}"
    local -i count=0
    local -i start=2

    local -a swap_arr

    IFS="," read -r -a swap_arr <<< "${PARTITION_SWAP}"

    if [[ "${swap_arr[2]}" == "partition" ]]; then
        start=3
    fi

    while :; do
        local -- replace="s/^[^,]*,/$(( count + start )),/g"

        local -- row

        row="$(printf "%s" "${PARTITION_DATA[${count}]}")"

        PARTITION_DATA[${count}]="$(printf "%s" "${row}" | sed "${replace}")"

        count=$(( count + 1 ))

        if [[ "${count}" -eq "${length}" ]]; then
            break
        fi
    done
}

print_scheme()
{
    ## Table structure:
    ##
    ##   Device, Type, Size, Filesystem, Luks, Mountpoint, Name
    ##
    local arr
    local table

    table="DEVICE,TYPE,SIZE,FILESYSTEM,LUKS,MOUNTPOINT,NAME"
    table="${table}"$'\n'

    get_device_size_pretty "${PARTITION_DEVICE}"

    populate_disk_table()
    {
        table="$(printf "${table}%s,%s,%s,%s,%s,%s,%s"                    \
                        "${PARTITION_DEVICE}"                             \
                        "DISK"                                            \
                        "$(get_device_size_pretty "${PARTITION_DEVICE}")" \
                        ""                                                \
                        ""                                                \
                        ""                                                \
                        "")"
        table="${table}"$'\n'
    }

    populate_boot_table()
    {
        IFS="," read -ra arr <<< "${PARTITION_BOOT}"

        table="$(printf "${table}%s,%s,%s,%s,%s,%s,%s"     \
                        "${PARTITION_DEVICE}${arr[0]}"     \
                        "PART"                             \
                        "$(pretty_print_size "${arr[1]}")" \
                        "${arr[2]}"                        \
                        "no"                               \
                        "${arr[3]}"                        \
                        "EFI Boot Partition")"
        table="${table}"$'\n'
    }

    populate_swap_table()
    {
        IFS="," read -r -a arr <<< "${PARTITION_SWAP}"

        if [[ "${swap_arr[2]}" == "partition" ]]; then
            table="$(printf "${table}%s,%s,%s,%s,%s,%s,%s" \
                       "${PARTITION_DEVICE}${arr[0]}"      \
                       "SWAP"                              \
                       "$(pretty_print_size "${arr[1]}")"  \
                       "${arr[3]}"                         \
                       "no"                                \
                       "[SWAP]"                            \
                       "Swap Partition")"
            table="${table}"$'\n'
        fi
    }

    populate_data_table()
    {
        local data

        for data in "${PARTITION_DATA[@]}"; do
            IFS="," read -r -a arr <<< "${data}"

            table="$(printf "${table}%s,%s,%s,%s,%s,%s,%s" \
                       "${PARTITION_DEVICE}${arr[0]}"      \
                       "PART"                              \
                       "$(pretty_print_size "${arr[1]}")"  \
                       "${arr[2]}"                         \
                       "${arr[3]}"                         \
                       "${arr[4]}"                         \
                       "${arr[5]}")"
            table="${table}"$'\n'
        done
    }

    print_info "Current Partition Scheme:"

    populate_disk_table
    populate_boot_table
    populate_swap_table
    populate_data_table

    column -t -s ',' <<< "${table}"

    printf "\n"
}

select_partition()
{
    local -a partitions=( "${PARTITION_DATA[@]}" )
    local -a select_arr=()

    local -- part

    if [[ "$#" -gt 0 && "$1" == "disable_root" ]]; then
        partitions=( "${partitions[@]:1}" )
    fi

    for part in "${partitions[@]}"; do
        local -- id

        id="$(print "%s" "${part}" | sed 's/,.*//')"
        select_arr+=( "${PARTITION_DEVICE}${id}" )
    done

    selection "Which device would you like to modify?" \
              "${select_arr[@]}"                       \
              "back"

    [[ "${SELECTION_VALUE}" == "back" ]] && return 1

    return 0
}

add_partition()
{
    local name
    local size
    local filesystem
    local luks
    local mountpoint

    if [[ "${PARTITION_DEVICE_SIZE_REMAINING}" -eq 0 ]]; then
        pause_function "Can not create a partition with no disk space"
        return 0
    fi

    print_title "PARTITION - Create Partition Scheme - Add Partition"
}

remove_partition()
{
    print_title "PARTITION - Create Partition Scheme - Remove Partition"

    select_partition "disable_root" || return 0
}

create_partition_scheme()
{
    while :; do
        print_title "PARTITION - Create Partition Scheme"

        print_scheme

        sleep 2
        continue

        print_info "Space Remaining: ${PARTITION_DEVICE_SIZE_REMAINING}GB"

        selection "What would you like to do?" \
                  "Add a Partition"    \
                  "Remove a Partition" \
                  "Extend a Partition" \
                  "Shrink a Partition" \
                  "Toggle LUKS"        \
                  "Set Filesystem"     \
                  "Set Mountpoint"     \
                  "Set Name"           \
                  "Done"

        case "${SELECTION_VALUE}" in
            "Add a Partition")
                add_partition
                ;;
            "Remove a Partition")
                remove_partition
                ;;
            "Extend a Partition")
                extend_partition
                ;;
            "Shrink a Partition")
                shrink_partition
                ;;
            "Toggle LUKS")
                toggle_luks
                ;;
            "Set Filesystem")
                set_filesystem
                ;;
            "Set Mountpoint")
                set_mountpoint
                ;;
            "Set Name")
                set_name
                ;;
            "Done")
                break
                ;;
        esac
    done
}


## PARTITION_LIST is a structure for creating partitions
## The structure is as follows:
##
##   ID,Size,Filesystem,Mountpoint,Name,Encrypt,Type,Modify
##
## ID         (Device ID)
## Size       (Partition Size)       []
## Filesystem (Partition Filesystem) [ext2,ex3,ext4,btrfs,fat32,vfat]
## Mountpoint (Partition Mountpoint) [string]
## Name       (Partition Name)       [string]
## Encrypt    (Partition Encryption) []
## Swap       (Partition Swap)       [partition,file]
## Modify     (Partition Modifyable) []
##
## Note: This structure is an array
##

################################################################################
## Create Partition
################################################################################

## https://wiki.archlinux.org/index.php/Partitioning
##
create_partitiona()
{
    local boot_str="0:0:+512M"
    local swap_str="0:0:+${PARTITION_SWAP_SIZE_GB}G"
    local data_str="0:0:+${PARTITION_DATA_SIZE_GB}G"

    sgdisk -Z "${PARTITION_MOUNT}"

    sgdisk -n "${boot_str}" -t 0:ef00 -c 0:"EFI Boot Partition" "${PARTITION_DEVICE}"
    sgdisk -n "${swap_str}" -t 0:8200 -c 0:"Swap Partition"     "${PARTITION_DEVICE}"
    sgdisk -n "${data_str}" -t 0:8300 -c 0:"Data Partition"     "${PARTITION_DEVICE}"
}

################################################################################
## LUKS
################################################################################

## https://wiki.archlinux.org/index.php/LUKS
##
setup_luks()
{
    local title="LUKS Setup"
    local info="Would you like to setup LUKS?"
    local allow_discards=""

    print_title "${title}"

    get_input "${info}"

    if [[ "${OPTION}" == 'n' ]]; then
        return 0
    fi

    if get_trim "${PARTITION_DEVICE}"; then
        PARTITION_DEVICE_TRIM=1
    fi

    if [[ "${PARTITION_DEVICE_TRIM}" -eq 1 ]]; then
        allow_discards="--allow-discards"
    fi

    cryptsetup --cipher aes-xts-plain64 \
               --key-size 512           \
               --hash sha512            \
               --iter-time 5000         \
               --use-random             \
               --verify-passphrase      \
               luksFormat "${PARTITION_DEVICE}3"

    cryptsetup open "${PARTITION_MOUNT}3" \
               --type luks                \
               "${allow_discards} "       \
               crypt

    PARTITION_LUKS=1
    PARTITION_LUKS_DISK=$(printf "${PARTITION_MOUNT}3" | sed 's/\/dev\///')
}

################################################################################
## Formatting & Mounting
################################################################################

## https://wiki.archlinux.org/index.php/File_Systems
##
format_partition()
{
    local trim=0

    if get_trim "${PARTITION_MOUNT}"; then
        trim=1
    fi

    mkfs.fat -F32 "${PARTITION_MOUNT}1"
    mkfs.vfat "${PARTITION_MOUNT}2"
    mkfs.ext4 "${PARTITION_MOUNT}3" "$([[ $trim -eq 1 ]] && printf "-E discard")"
}

mount_partitions()
{
    mount "${PARTITION_MOUNT}3" /mnt
    mkdir /mnt/boot
    mount "${PARTITION_MOUNT}1" /mnt/boot
}

################################################################################
## Formatting & Mounting
################################################################################
partition_disk()
{
#    local partition_layouts=("Default" "LVM")
#    print_title "Partition Layout"
#    selection "Select a partition scheme:" "${partition_layouts[@]}"

    select_device

    umount_partitions

    create_boot_partition
    create_swap_partition
    create_root_partition

    create_partition_scheme
    exit 0
    create_partition
    setup_luks
    format_partition
    mount_partitions
}
